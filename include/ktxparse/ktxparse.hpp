// ktxparse 0.1.0
// A simple KTX texture parser for OpenGL
// https://github.com/sevmeyer/ktxparse
//
// Copyright 2019 Severin Meyer
// Distributed under the Boost Software License 1.0
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.


// References:
// https://khronos.org/opengles/sdk/tools/KTX/file_format_spec
// https://github.com/KhronosGroup/OpenGL-Registry/blob/master/xml/gl.xml
// https://github.com/KhronosGroup/KTX-Software/blob/master/lib/gl_format.h
// https://github.com/KhronosGroup/KTX-Specification/blob/master/formats.json


#ifndef KTXPARSE_KTXPARSE_HPP_INCLUDED
#define KTXPARSE_KTXPARSE_HPP_INCLUDED


#include <cstddef>   // size_t
#include <cstdint>   // uint8_t, int32_t, uint32_t
#include <cstring>   // memcmp, memcpy
#include <algorithm> // max


namespace ktxparse {
namespace detail {


using std::size_t;
using std::uint8_t;
using std::int32_t;
using std::uint32_t;


struct TargetInfo
{
	uint32_t target;
	uint32_t dimensions;
	uint32_t width;
	uint32_t height;
	uint32_t depth;
	uint32_t minWidth;
	uint32_t minHeight;
	uint32_t minDepth;

	explicit operator bool() const
	{
		return target != 0;
	}

	bool isNonArrayCubemap() const
	{
		return target == 0x8513; // GL_TEXTURE_CUBE_MAP
	}

	uint32_t getFaceTarget(uint32_t face) const
	{
		if (isNonArrayCubemap() && face < 6)
			return 0x8515 + face; // GL_TEXTURE_CUBE_MAP_POSITIVE_X

		return face == 0 ? target : 0;
	}
};


inline TargetInfo getTargetInfo(uint32_t width, uint32_t height, uint32_t depth, uint32_t layers, uint32_t faces)
{
	const bool is1D{width > 0 && height == 0 && depth == 0 && faces == 1};
	const bool is2D{width > 0 && height  > 0 && depth == 0 && faces == 1};
	const bool is3D{width > 0 && height  > 0 && depth  > 0 && faces == 1};
	const bool isCM{width > 0 && height == width && depth == 0 && faces == 6};

	if (layers > 0)
	{
		if (is1D) // GL_TEXTURE_1D_ARRAY
			return {0x8C18,2,width,layers,1,1,layers,1};
		if (is2D) // GL_TEXTURE_2D_ARRAY
			return {0x8C1A,3,width,height,layers,1,1,layers};
		if (isCM) // GL_TEXTURE_CUBE_MAP_ARRAY
			return {0x9009,3,width,height,layers*faces,1,1,layers*faces};
	}
	else
	{
		if (is1D) // GL_TEXTURE_1D
			return {0x0DE0,1,width,1,1,1,1,1};
		if (is2D) // GL_TEXTURE_2D
			return {0x0DE1,2,width,height,1,1,1,1};
		if (is3D) // GL_TEXTURE_3D
			return {0x806F,3,width,height,depth,1,1,1};
		if (isCM) // GL_TEXTURE_CUBE_MAP
			return {0x8513,2,width,height,1,1,1,1};
	}

	return {0,0,0,0,0,0,0,0};
}


struct FormatInfo
{
	uint32_t internalFormat;
	uint32_t format;
	uint32_t type;
	uint32_t typeSize;
	uint32_t blockWidth;
	uint32_t blockHeight;
	uint32_t blockDepth;
	uint32_t blockSize;

	explicit operator bool() const
	{
		return internalFormat != 0;
	}

	bool isCompressed() const
	{
		return format == 0;
	}

	uint32_t getImageSize(uint32_t width, uint32_t height, uint32_t depth, uint32_t align) const
	{
		if (align > 0 && blockWidth == 1 && blockHeight == 1 && blockDepth == 1)
		{
			const uint32_t rowSize{((width*blockSize + align - 1) / align) * align};
			return rowSize * height * depth;
		}

		const uint32_t xBlocks{(width  + blockWidth  - 1) / blockWidth};
		const uint32_t yBlocks{(height + blockHeight - 1) / blockHeight};
		const uint32_t zBlocks{(depth  + blockDepth  - 1) / blockDepth};
		return xBlocks * yBlocks * zBlocks * blockSize;
	}
};


inline FormatInfo getFormatInfo(uint32_t internalFormat, uint32_t format, uint32_t type)
{
	struct IntermediateFormatInfo
	{
		uint32_t format;
		uint32_t formatRev;
		uint32_t type;
		uint32_t typeRev;
		uint32_t typeSize;
		uint32_t blockWidth;
		uint32_t blockHeight;
		uint32_t blockDepth;
		uint32_t blockSize;
	} i{0,0,0,0,0,0,0,0,0};

	switch (internalFormat)
	{
		case 0x2A10: // GL_R3_G3_B2
			i = {0x1907,0x80E0,0x8032,0x8362,1,1,1,1,1}; break;
		case 0x8051: // GL_RGB8
		case 0x8C41: // GL_SRGB8
			i = {0x1907,0x80E0,0x1401,0,1,1,1,1,3}; break;
		case 0x8054: // GL_RGB16
			i = {0x1907,0x80E0,0x1403,0,2,1,1,1,6}; break;
		case 0x8056: // GL_RGBA4
			i = {0x1908,0x80E1,0x8033,0x8365,2,1,1,1,2}; break;
		case 0x8057: // GL_RGB5_A1
			i = {0x1908,0x80E1,0x8034,0x8366,2,1,1,1,2}; break;
		case 0x8058: // GL_RGBA8
		case 0x8C43: // GL_SRGB8_ALPHA8
			i = {0x1908,0x80E1,0x1401,0,1,1,1,1,4}; break;
		case 0x8059: // GL_RGB10_A2
			i = {0x1908,0x80E1,0x8036,0x8368,4,1,1,1,4}; break;
		case 0x805B: // GL_RGBA16
			i = {0x1908,0x80E1,0x1403,0,2,1,1,1,8}; break;
		case 0x81A5: // GL_DEPTH_COMPONENT16
			i = {0x1902,0,0x1403,0,2,1,1,1,2}; break;
		case 0x81A6: // GL_DEPTH_COMPONENT24
			i = {0x1902,0,0x1405,0,4,1,1,1,4}; break;
		case 0x8229: // GL_R8
		case 0x8FBD: // GL_SR8_EXT
			i = {0x1903,0,0x1401,0,1,1,1,1,1}; break;
		case 0x822A: // GL_R16
			i = {0x1903,0,0x1403,0,2,1,1,1,2}; break;
		case 0x822B: // GL_RG8
		case 0x8FBE: // GL_SRG8_EXT
			i = {0x8227,0,0x1401,0,1,1,1,1,2}; break;
		case 0x822C: // GL_RG16
			i = {0x8227,0,0x1403,0,2,1,1,1,4}; break;
		case 0x822D: // GL_R16F
			i = {0x1903,0,0x140B,0,2,1,1,1,2}; break;
		case 0x822E: // GL_R32F
			i = {0x1903,0,0x1406,0,4,1,1,1,4}; break;
		case 0x822F: // GL_RG16F
			i = {0x8227,0,0x140B,0,2,1,1,1,4}; break;
		case 0x8230: // GL_RG32F
			i = {0x8227,0,0x1406,0,4,1,1,1,8}; break;
		case 0x8231: // GL_R8I
			i = {0x8D94,0,0x1400,0,1,1,1,1,1}; break;
		case 0x8232: // GL_R8UI
			i = {0x8D94,0,0x1401,0,1,1,1,1,1}; break;
		case 0x8233: // GL_R16I
			i = {0x8D94,0,0x1402,0,2,1,1,1,2}; break;
		case 0x8234: // GL_R16UI
			i = {0x8D94,0,0x1403,0,2,1,1,1,2}; break;
		case 0x8235: // GL_R32I
			i = {0x8D94,0,0x1404,0,4,1,1,1,4}; break;
		case 0x8236: // GL_R32UI
			i = {0x8D94,0,0x1405,0,4,1,1,1,4}; break;
		case 0x8237: // GL_RG8I
			i = {0x8228,0,0x1400,0,1,1,1,1,2}; break;
		case 0x8238: // GL_RG8UI
			i = {0x8228,0,0x1401,0,1,1,1,1,2}; break;
		case 0x8239: // GL_RG16I
			i = {0x8228,0,0x1402,0,2,1,1,1,4}; break;
		case 0x823A: // GL_RG16UI
			i = {0x8228,0,0x1403,0,2,1,1,1,4}; break;
		case 0x823B: // GL_RG32I
			i = {0x8228,0,0x1404,0,4,1,1,1,8}; break;
		case 0x823C: // GL_RG32UI
			i = {0x8228,0,0x1405,0,4,1,1,1,8}; break;
		case 0x83F0: // GL_COMPRESSED_RGB_S3TC_DXT1_EXT
		case 0x83F1: // GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
		case 0x8C4C: // GL_COMPRESSED_SRGB_S3TC_DXT1_EXT
		case 0x8C4D: // GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
		case 0x8C70: // GL_COMPRESSED_LUMINANCE_LATC1_EXT
		case 0x8C71: // GL_COMPRESSED_SIGNED_LUMINANCE_LATC1_EXT
		case 0x8C92: // GL_ATC_RGB_AMD
		case 0x8D64: // GL_ETC1_RGB8_OES
		case 0x8DBB: // GL_COMPRESSED_RED_RGTC1
		case 0x8DBC: // GL_COMPRESSED_SIGNED_RED_RGTC1
		case 0x9138: // GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG
		case 0x9270: // GL_COMPRESSED_R11_EAC
		case 0x9271: // GL_COMPRESSED_SIGNED_R11_EAC
		case 0x9274: // GL_COMPRESSED_RGB8_ETC2
		case 0x9275: // GL_COMPRESSED_SRGB8_ETC2
		case 0x9276: // GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
		case 0x9277: // GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
		case 0x93F1: // GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG
			i = {0,0,0,0,1,4,4,1,8}; break;
		case 0x83F2: // GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
		case 0x83F3: // GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
		case 0x87EE: // GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD
		case 0x8C4E: // GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
		case 0x8C4F: // GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
		case 0x8C72: // GL_COMPRESSED_LUMINANCE_ALPHA_LATC2_EXT
		case 0x8C93: // GL_ATC_RGBA_EXPLICIT_ALPHA_AMD
		case 0x8DBD: // GL_COMPRESSED_RG_RGTC2
		case 0x8DBE: // GL_COMPRESSED_SIGNED_RG_RGTC2
		case 0x8E8C: // GL_COMPRESSED_RGBA_BPTC_UNORM
		case 0x8E8D: // GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM
		case 0x8E8E: // GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT
		case 0x8E8F: // GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT
		case 0x9272: // GL_COMPRESSED_RG11_EAC
		case 0x9273: // GL_COMPRESSED_SIGNED_RG11_EAC
		case 0x9278: // GL_COMPRESSED_RGBA8_ETC2_EAC
		case 0x9279: // GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
		case 0x93B0: // GL_COMPRESSED_RGBA_ASTC_4x4_KHR
		case 0x93D0: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
			i = {0,0,0,0,1,4,4,1,16}; break;
		case 0x8814: // GL_RGBA32F
			i = {0x1908,0x80E1,0x1406,0,4,1,1,1,16}; break;
		case 0x8815: // GL_RGB32F
			i = {0x1907,0x80E0,0x1406,0,4,1,1,1,12}; break;
		case 0x881A: // GL_RGBA16F
			i = {0x1908,0x80E1,0x140B,0,2,1,1,1,8}; break;
		case 0x881B: // GL_RGB16F
			i = {0x1907,0x80E0,0x140B,0,2,1,1,1,6}; break;
		case 0x88F0: // GL_DEPTH24_STENCIL8
			i = {0x84F9,0,0x84FA,0,4,1,1,1,4}; break;
		case 0x8A54: // GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT
		case 0x8A56: // GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT
		case 0x8C01: // GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG
		case 0x8C03: // GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
			i = {0,0,0,0,1,16,8,1,32}; break;
		case 0x8A55: // GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT
		case 0x8A57: // GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT
		case 0x8C00: // GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG
		case 0x8C02: // GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
			i = {0,0,0,0,1,8,8,1,32}; break;
		case 0x8C3A: // GL_R11F_G11F_B10F
			i = {0x1907,0x80E0,0,0x8C3B,4,1,1,1,4}; break;
		case 0x8C3D: // GL_RGB9_E5
			i = {0x1907,0x80E0,0,0x8C3E,4,1,1,1,4}; break;
		case 0x8CAC: // GL_DEPTH_COMPONENT32F
			i = {0x1902,0,0x1406,0,4,1,1,1,4}; break;
		case 0x8CAD: // GL_DEPTH32F_STENCIL8
			i = {0x84F9,0,0,0x8DAD,4,1,1,1,8}; break;
		case 0x8D48: // GL_STENCIL_INDEX8
			i = {0x1901,0,0x1401,0,1,1,1,1,1}; break;
		case 0x8D62: // GL_RGB565
			i = {0x1907,0x80E0,0x8363,0x8364,2,1,1,1,2}; break;
		case 0x8D70: // GL_RGBA32UI
			i = {0x8D99,0x8D9B,0x1405,0,4,1,1,1,16}; break;
		case 0x8D71: // GL_RGB32UI
			i = {0x8D98,0x8D9A,0x1405,0,4,1,1,1,12}; break;
		case 0x8D76: // GL_RGBA16UI
			i = {0x8D99,0x8D9B,0x1403,0,2,1,1,1,8}; break;
		case 0x8D77: // GL_RGB16UI
			i = {0x8D98,0x8D9A,0x1403,0,2,1,1,1,6}; break;
		case 0x8D7C: // GL_RGBA8UI
			i = {0x8D99,0x8D9B,0x1401,0,1,1,1,1,4}; break;
		case 0x8D7D: // GL_RGB8UI
			i = {0x8D98,0x8D9A,0x1401,0,1,1,1,1,3}; break;
		case 0x8D82: // GL_RGBA32I
			i = {0x8D99,0x8D9B,0x1404,0,4,1,1,1,16}; break;
		case 0x8D83: // GL_RGB32I
			i = {0x8D98,0x8D9A,0x1404,0,4,1,1,1,12}; break;
		case 0x8D88: // GL_RGBA16I
			i = {0x8D99,0x8D9B,0x1402,0,2,1,1,1,8}; break;
		case 0x8D89: // GL_RGB16I
			i = {0x8D98,0x8D9A,0x1402,0,2,1,1,1,6}; break;
		case 0x8D8E: // GL_RGBA8I
			i = {0x8D99,0x8D9B,0x1400,0,1,1,1,1,4}; break;
		case 0x8D8F: // GL_RGB8I
			i = {0x8D98,0x8D9A,0x1400,0,1,1,1,1,3}; break;
		case 0x8F94: // GL_R8_SNORM
			i = {0x1903,0,0x1400,0,1,1,1,1,1}; break;
		case 0x8F95: // GL_RG8_SNORM
			i = {0x8227,0,0x1400,0,1,1,1,1,2}; break;
		case 0x8F96: // GL_RGB8_SNORM
			i = {0x1907,0x80E0,0x1400,0,1,1,1,1,3}; break;
		case 0x8F97: // GL_RGBA8_SNORM
			i = {0x1908,0x80E1,0x1400,0,1,1,1,1,4}; break;
		case 0x8F98: // GL_R16_SNORM
			i = {0x1903,0,0x1402,0,2,1,1,1,2}; break;
		case 0x8F99: // GL_RG16_SNORM
			i = {0x8227,0,0x1402,0,2,1,1,1,4}; break;
		case 0x8F9A: // GL_RGB16_SNORM
			i = {0x1907,0x80E0,0x1402,0,2,1,1,1,6}; break;
		case 0x8F9B: // GL_RGBA16_SNORM
			i = {0x1908,0x80E1,0x1402,0,2,1,1,1,8}; break;
		case 0x906F: // GL_RGB10_A2UI
			i = {0x8D99,0x8D9B,0x8036,0x8368,4,1,1,1,4}; break;
		case 0x9137: // GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG
		case 0x93F0: // GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG
			i = {0,0,0,0,1,8,4,1,8}; break;
		case 0x93B1: // GL_COMPRESSED_RGBA_ASTC_5x4_KHR
		case 0x93D1: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
			i = {0,0,0,0,1,5,4,1,16}; break;
		case 0x93B2: // GL_COMPRESSED_RGBA_ASTC_5x5_KHR
		case 0x93D2: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
			i = {0,0,0,0,1,5,5,1,16}; break;
		case 0x93B3: // GL_COMPRESSED_RGBA_ASTC_6x5_KHR
		case 0x93D3: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
			i = {0,0,0,0,1,6,5,1,16}; break;
		case 0x93B4: // GL_COMPRESSED_RGBA_ASTC_6x6_KHR
		case 0x93D4: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
			i = {0,0,0,0,1,6,6,1,16}; break;
		case 0x93B5: // GL_COMPRESSED_RGBA_ASTC_8x5_KHR
		case 0x93D5: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
			i = {0,0,0,0,1,8,5,1,16}; break;
		case 0x93B6: // GL_COMPRESSED_RGBA_ASTC_8x6_KHR
		case 0x93D6: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
			i = {0,0,0,0,1,8,6,1,16}; break;
		case 0x93B7: // GL_COMPRESSED_RGBA_ASTC_8x8_KHR
		case 0x93D7: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
			i = {0,0,0,0,1,8,8,1,16}; break;
		case 0x93B8: // GL_COMPRESSED_RGBA_ASTC_10x5_KHR
		case 0x93D8: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
			i = {0,0,0,0,1,10,5,1,16}; break;
		case 0x93B9: // GL_COMPRESSED_RGBA_ASTC_10x6_KHR
		case 0x93D9: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
			i = {0,0,0,0,1,10,6,1,16}; break;
		case 0x93BA: // GL_COMPRESSED_RGBA_ASTC_10x8_KHR
		case 0x93DA: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
			i = {0,0,0,0,1,10,8,1,16}; break;
		case 0x93BB: // GL_COMPRESSED_RGBA_ASTC_10x10_KHR
		case 0x93DB: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
			i = {0,0,0,0,1,10,10,1,16}; break;
		case 0x93BC: // GL_COMPRESSED_RGBA_ASTC_12x10_KHR
		case 0x93DC: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
			i = {0,0,0,0,1,12,10,1,16}; break;
		case 0x93BD: // GL_COMPRESSED_RGBA_ASTC_12x12_KHR
		case 0x93DD: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
			i = {0,0,0,0,1,12,12,1,16}; break;
		case 0x93C0: // GL_COMPRESSED_RGBA_ASTC_3x3x3_OES
		case 0x93E0: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES
			i = {0,0,0,0,1,3,3,3,16}; break;
		case 0x93C1: // GL_COMPRESSED_RGBA_ASTC_4x3x3_OES
		case 0x93E1: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES
			i = {0,0,0,0,1,4,3,3,16}; break;
		case 0x93C2: // GL_COMPRESSED_RGBA_ASTC_4x4x3_OES
		case 0x93E2: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES
			i = {0,0,0,0,1,4,4,3,16}; break;
		case 0x93C3: // GL_COMPRESSED_RGBA_ASTC_4x4x4_OES
		case 0x93E3: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES
			i = {0,0,0,0,1,4,4,4,16}; break;
		case 0x93C4: // GL_COMPRESSED_RGBA_ASTC_5x4x4_OES
		case 0x93E4: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES
			i = {0,0,0,0,1,5,4,4,16}; break;
		case 0x93C5: // GL_COMPRESSED_RGBA_ASTC_5x5x4_OES
		case 0x93E5: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES
			i = {0,0,0,0,1,5,5,4,16}; break;
		case 0x93C6: // GL_COMPRESSED_RGBA_ASTC_5x5x5_OES
		case 0x93E6: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES
			i = {0,0,0,0,1,5,5,5,16}; break;
		case 0x93C7: // GL_COMPRESSED_RGBA_ASTC_6x5x5_OES
		case 0x93E7: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES
			i = {0,0,0,0,1,6,5,5,16}; break;
		case 0x93C8: // GL_COMPRESSED_RGBA_ASTC_6x6x5_OES
		case 0x93E8: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES
			i = {0,0,0,0,1,6,6,5,16}; break;
		case 0x93C9: // GL_COMPRESSED_RGBA_ASTC_6x6x6_OES
		case 0x93E9: // GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES
			i = {0,0,0,0,1,6,6,6,16}; break;
	}

	const bool isValidFormat{format == i.format || format == i.formatRev};
	const bool isValidType{type == i.type || type == i.typeRev};

	if (isValidFormat && isValidType)
		return {
			internalFormat,
			format,
			type,
			i.typeSize,
			i.blockWidth,
			i.blockHeight,
			i.blockDepth,
			i.blockSize};

	return {0,0,0,0,0,0,0,0};
}


class Stream
{
	public:

		Stream() = default;

		Stream(const uint8_t* data, size_t size) :
			data_{data},
			size_{size}
		{}

		void swapBytes(bool isByteSwapped)
		{
			isByteSwapped_ = isByteSwapped;
		}

		const uint8_t* bytes(size_t count)
		{
			if (data_ == nullptr || count > size_ - pos_)
			{
				pos_ = size_;
				return nullptr;
			}

			pos_ += count;
			return data_ + (pos_ - count);
		}

		uint32_t uint32()
		{
			uint32_t i{0};
			const uint8_t* src{bytes(4)};

			if (src != nullptr)
				std::memcpy(&i, src, 4);

			if (isByteSwapped_)
				return i << 24 | (i & 0xFF00) << 8 | (i & 0xFF0000) >> 8 | i >> 24;

			return i;
		}

		void align4()
		{
			bytes((4 - (pos_ & 0x3)) & 0x3);
		}

	private:

		const uint8_t* data_{nullptr};

		// INVARIANT: pos_ <= size_
		size_t size_{0};
		size_t pos_{0};

		bool isByteSwapped_{false};
};


struct Image
{
	uint32_t target;
	int32_t  level;
	int32_t  internalformat;
	uint32_t width;
	uint32_t height;
	uint32_t depth;
	uint32_t format;
	uint32_t type;
	uint32_t size;
	const uint8_t* data;
};


class ImageIterator
{
	public:

		ImageIterator(
				const TargetInfo& targetInfo,
				const FormatInfo& formatInfo,
				Stream stream,
				uint32_t level) :
			targetInfo_{targetInfo},
			formatInfo_{formatInfo},
			stream_{stream},
			level_{level},
			face_{0},
			size_{stream_.uint32()},
			data_{stream_.bytes(size_)}
		{}

		bool operator==(const ImageIterator& other) const
		{
			return level_ == other.level_ && face_ == other.face_;
		}

		bool operator!=(const ImageIterator& other) const
		{
			return !operator==(other);
		}

		Image operator*() const
		{
			return {
				targetInfo_.getFaceTarget(face_),
				static_cast<int32_t>(level_),
				static_cast<int32_t>(formatInfo_.internalFormat),
				std::max(targetInfo_.minWidth,  targetInfo_.width  >> level_),
				std::max(targetInfo_.minHeight, targetInfo_.height >> level_),
				std::max(targetInfo_.minDepth,  targetInfo_.depth  >> level_),
				formatInfo_.isCompressed()
					? formatInfo_.internalFormat
					: formatInfo_.format,
				formatInfo_.type,
				size_,
				data_};
		}

		ImageIterator& operator++()
		{
			stream_.align4();

			if (targetInfo_.isNonArrayCubemap() && face_ < 5)
				++face_;
			else
			{
				++level_;
				face_ = 0;
				size_ = stream_.uint32();
			}

			data_ = stream_.bytes(size_);
			return *this;
		}

	private:

		const TargetInfo& targetInfo_;
		const FormatInfo& formatInfo_;

		Stream stream_;

		uint32_t level_;
		uint32_t face_;
		uint32_t size_;

		const uint8_t* data_;
};


struct Texture
{
	uint32_t target;
	uint32_t dimensions;       // For gl*D()
	uint32_t levels;           // Ignores shouldGenerateMipmap
	uint32_t internalformat;
	uint32_t width;
	uint32_t height;
	uint32_t depth;

	bool isByteSwapped;        // For GL_UNPACK_SWAP_BYTES
	bool isCompressed;         // For glCompressed*()
	bool shouldGenerateMipmap; // For glGenerateMipmap()

	// Parses data from memory.
	// Can handle nullptr.
	Texture(const uint8_t* data, size_t size)
	{
		static constexpr uint8_t ktx11[12]{
			0xAB,0x4B,0x54,0x58,
			0x20,0x31,0x31,0xBB,
			0x0D,0x0A,0x1A,0x0A};

		Stream stream{data, size};

		// Identifier
		const uint8_t* identifier{stream.bytes(12)};
		if (identifier == nullptr || std::memcmp(identifier, ktx11, 12) != 0)
			return;

		// Endianness
		const uint32_t endianness{stream.uint32()};
		stream.swapBytes(endianness == 0x01020304);

		// Header
		const uint32_t glType{stream.uint32()};
		stream.uint32(); // Ignore glTypeSize
		const uint32_t glFormat{stream.uint32()};
		const uint32_t glInternalFormat{stream.uint32()};
		stream.uint32(); // Ignore glBaseInternalFormat
		const uint32_t pixelWidth{stream.uint32()};
		const uint32_t pixelHeight{stream.uint32()};
		const uint32_t pixelDepth{stream.uint32()};
		const uint32_t numberOfArrayElements{stream.uint32()};
		const uint32_t numberOfFaces{stream.uint32()};
		const uint32_t numberOfMipmapLevels{stream.uint32()};
		const uint32_t bytesOfKeyValueData{stream.uint32()};
		stream.bytes(bytesOfKeyValueData);

		// Private members
		pixelStream_ = Stream{stream};
		endLevel_    = std::max<uint32_t>(1, numberOfMipmapLevels);
		formatInfo_  = getFormatInfo(glInternalFormat, glFormat, glType);
		targetInfo_  = getTargetInfo(
			pixelWidth,
			pixelHeight,
			pixelDepth,
			numberOfArrayElements,
			numberOfFaces);

		if (!targetInfo_ || !formatInfo_)
			return;

		// Public members
		target         = targetInfo_.target;
		dimensions     = targetInfo_.dimensions;
		levels         = endLevel_;
		internalformat = formatInfo_.internalFormat;
		width          = targetInfo_.width;
		height         = targetInfo_.height;
		depth          = targetInfo_.depth;
		isByteSwapped  = formatInfo_.typeSize > 1 && endianness == 0x01020304;
		isCompressed   = formatInfo_.isCompressed();
		shouldGenerateMipmap = numberOfMipmapLevels == 0;

		// Image validation
		for (Image img : *this)
		{
			if (img.size != formatInfo_.getImageSize(img.width, img.height, img.depth, 4))
				return;
			if (img.data == nullptr)
				return;
		}

		isValid_ = true;
	}

	// Checks if the construction was successful.
	// Alterations to public members are ignored.
	explicit operator bool() const
	{
		return isValid_;
	}

	ImageIterator begin() const
	{
		return {targetInfo_, formatInfo_, Stream{pixelStream_}, 0};
	}

	ImageIterator end() const
	{
		return {targetInfo_, formatInfo_, Stream{}, endLevel_};
	}

	private:

		TargetInfo targetInfo_;
		FormatInfo formatInfo_;

		Stream pixelStream_;
		uint32_t endLevel_;

		bool isValid_{false};
};


} // namespace detail


// Public types
using detail::Image;
using detail::ImageIterator;
using detail::Texture;


} // namespace ktxparse

#endif // KTXPARSE_KTXPARSE_HPP_INCLUDED
